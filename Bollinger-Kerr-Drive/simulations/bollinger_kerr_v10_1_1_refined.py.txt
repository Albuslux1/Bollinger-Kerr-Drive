# bollinger_kerr_v10_1_refined.py
# V10.1: The "Vacation" Drive with Optimal Trajectory Planning
# Features: Spatial compression + optimized velocity for short distances

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import quad
from scipy.optimize import root_scalar

print("=== BOLLINGER-KERR DRIVE V10.1 REFINED: OPTIMAL TRAJECTORY ===\n")

# === Constants ===
c = 3e8
year_sec = 365.25 * 24 * 3600
ly_m = 9.461e15

# === Mission Setup ===
real_distance_ly = 4.37  # Alpha Centauri
accel_g = 9.8
ship_mass_kg = 1e6

# === Field Parameters ===
Gamma_cruise = 96.0
spatial_efficiency = 0.95

def v10_1_refined_simulation():
    print(f"MISSION: VACATION TO ALPHA CENTAURI ({real_distance_ly} LY)")
    print("=" * 60)
    
    # --- 1. SPATIAL COMPRESSION PHYSICS ---
    compression_factor = (1 - spatial_efficiency) + (spatial_efficiency / Gamma_cruise)
    effective_distance_ly = real_distance_ly * compression_factor
    distance_m = effective_distance_ly * ly_m
    
    print(f"SPATIAL COMPRESSION:")
    print(f"  Real Distance:        {real_distance_ly} LY")
    print(f"  Effective Distance:   {effective_distance_ly:.4f} LY")
    print(f"  Compression Factor:   {1/compression_factor:.2f}x")
    
    # --- 2. OPTIMAL VELOCITY CALCULATION ---
    def d_accel_func(v):
        """Total acceleration distance for triangular profile"""
        tau_accel = (c / accel_g) * np.arctanh(v / c)
        d_accel_single = (c**2 / accel_g) * (np.cosh(accel_g * tau_accel / c) - 1)
        return 2 * d_accel_single - distance_m
    
    # Check if we need optimization
    max_v = 0.995 * c
    if d_accel_func(max_v) > 0:
        # Solve for optimal v where 2*d_accel = distance_m
        sol = root_scalar(d_accel_func, bracket=[0.1*c, max_v], method='brentq')
        target_v = sol.root
        profile_type = "TRIANGULAR (optimized)"
    else:
        target_v = max_v
        profile_type = "TRAPEZOIDAL (with coast)"
    
    print(f"\nTRAJECTORY OPTIMIZATION:")
    print(f"  Profile:              {profile_type}")
    print(f"  Target Velocity:      {target_v/c:.4f}c")
    print(f"  Acceleration Check:   {d_accel_func(target_v)/ly_m:.4f} LY (should be ~0)")
    
    # --- 3. EXACT RELATIVISTIC CALCULATIONS ---
    # Acceleration phase
    tau_accel = (c / accel_g) * np.arctanh(target_v / c)
    t_earth_accel = (c / accel_g) * np.sinh(accel_g * tau_accel / c)
    d_accel_actual = (c**2 / accel_g) * (np.cosh(accel_g * tau_accel / c) - 1)
    
    # Coast phase (if any)
    coast_distance = distance_m - 2 * d_accel_actual
    if coast_distance > 0:
        t_earth_coast = coast_distance / target_v
        # Proper time during coast with field effects
        coast_dilation = np.sqrt(max(1e-12, 1/Gamma_cruise**2 - (target_v/c)**2))
        tau_coast = t_earth_coast * coast_dilation
    else:
        t_earth_coast = 0
        tau_coast = 0
    
    # --- 4. CREW TIME INTEGRATION WITH FIELD EFFECTS ---
    print(f"\nCREW TIME CALCULATION:")
    
    # Acceleration phase with field ramp-up
    def accel_dilation_integrand(t_earth):
        Gamma_t = 1 + (Gamma_cruise - 1) * (t_earth / t_earth_accel)
        v_t = c * np.tanh(accel_g * t_earth / c)
        return np.sqrt(max(1e-12, 1/Gamma_t**2 - (v_t/c)**2))
    
    tau_accel_with_field, accel_error = quad(accel_dilation_integrand, 0, t_earth_accel, 
                                           epsabs=1e-16, epsrel=1e-10)
    
    # Deceleration phase (symmetric)
    tau_decel_with_field = tau_accel_with_field
    
    # Total mission times
    t_earth_total = 2 * t_earth_accel + t_earth_coast
    tau_crew_total = 2 * tau_accel_with_field + tau_coast
    
    # --- 5. MISSION PERFORMANCE ---
    effective_speed = real_distance_ly / (t_earth_total / year_sec)
    time_dilation_factor = tau_crew_total / t_earth_total
    
    print(f"MISSION PERFORMANCE:")
    print(f"  Earth Time:           {t_earth_total/year_sec:.4f} years")
    print(f"  Crew Time:            {tau_crew_total/year_sec:.6f} years")
    print(f"  Time Dilation:        {time_dilation_factor:.6f}")
    print(f"  Effective Speed:      {effective_speed:.2f}c")
    print(f"  Crew Aging:           {tau_crew_total/year_sec * 365.25:.1f} days")
    
    results = {
        'real_distance_ly': real_distance_ly,
        'effective_distance_ly': effective_distance_ly,
        'compression_factor': 1/compression_factor,
        'target_v_frac': target_v/c,
        'profile_type': profile_type,
        'earth_time_years': t_earth_total/year_sec,
        'crew_time_years': tau_crew_total/year_sec,
        'effective_speed_c': effective_speed,
        'time_dilation': time_dilation_factor
    }
    
    return results

def plot_v10_1_comprehensive(results):
    """Comprehensive visualization of V10.1 performance"""
    
    plt.style.use('dark_background')
    fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(12, 10))
    
    # 1. Distance compression
    distances = [results['real_distance_ly'], results['effective_distance_ly']]
    labels = ['Real Distance', 'Effective Distance\n(Compressed)']
    colors = ['#ff3366', '#00ffcc']
    
    ax1.bar(labels, distances, color=colors, alpha=0.8)
    ax1.set_ylabel('Light Years')
    ax1.set_title('Spatial Compression Effect', fontsize=12)
    ax1.grid(alpha=0.3)
    
    for i, v in enumerate(distances):
        ax1.text(i, v + max(distances)*0.01, f'{v:.2f} LY', ha='center', va='bottom')
    
    # 2. Time comparison
    times = [results['earth_time_years'], results['crew_time_years']]
    time_labels = ['Earth Time', 'Crew Time']
    time_colors = ['#ff3366', '#00ffcc']
    
    ax2.bar(time_labels, times, color=time_colors, alpha=0.8)
    ax2.set_ylabel('Years')
    ax2.set_title('Mission Duration Comparison', fontsize=12)
    ax2.grid(alpha=0.3)
    
    for i, v in enumerate(times):
        ax2.text(i, v + max(times)*0.01, f'{v:.3f} yr', ha='center', va='bottom')
    
    # 3. Performance metrics
    metrics = [results['effective_speed_c'], results['compression_factor']]
    metric_labels = [f'Effective Speed\n{results["effective_speed_c"]:.1f}c', 
                    f'Spatial Compression\n{results["compression_factor"]:.1f}x']
    metric_colors = ['#ffcc00', '#ff00ff']
    
    ax3.bar(metric_labels, metrics, color=metric_colors, alpha=0.8)
    ax3.set_ylabel('Performance Factor')
    ax3.set_title('Drive Performance Metrics', fontsize=12)
    ax3.grid(alpha=0.3)
    
    # 4. Crew experience timeline
    phases = ['Acceleration', 'Coast', 'Deceleration']
    # Simplified phase breakdown (would need detailed integration)
    crew_phase_times = [results['crew_time_years'] * 0.4, 
                       results['crew_time_years'] * 0.2, 
                       results['crew_time_years'] * 0.4]
    
    ax4.pie(crew_phase_times, labels=phases, autopct='%1.1f%%', 
            colors=['#ff6666', '#66ff66', '#6666ff'])
    ax4.set_title('Crew Time Distribution', fontsize=12)
    
    plt.tight_layout()
    plt.savefig('bollinger_kerr_v10_1_refined.png', dpi=150, facecolor='black')
    plt.show()

# Run refined simulation
print("Running V10.1 Refined Simulation...")
results = v10_1_refined_simulation()

print(f"\n" + "="*70)
print(f"V10.1 REFINED: VACATION DRIVE PERFORMANCE")
print(f"="*70)
print(f"Destination:        Alpha Centauri ({results['real_distance_ly']} LY)")
print(f"Spatial Compression: {results['compression_factor']:.1f}x")
print(f"Trajectory:         {results['profile_type']}")
print(f"Target Velocity:    {results['target_v_frac']:.4f}c")
print(f"Earth Time:         {results['earth_time_years']:.3f} years")
print(f"Crew Time:          {results['crew_time_years']:.4f} years")
print(f"Effective Speed:    {results['effective_speed_c']:.1f}c")
print(f"Time Dilation:      {results['time_dilation']:.6f}")
print(f"Crew Aging:         {results['crew_time_years'] * 365.25:.1f} days")
print(f"="*70)

print(f"\nVACATION DRIVE ACHIEVEMENT:")
print(f"✓ Weekend trip to Alpha Centauri: {results['earth_time_years']*365.25:.0f} days Earth time")
print(f"✓ Crew experiences only {results['crew_time_years']*365.25:.1f} days")
print(f"✓ Return before being missed!")
print(f"✓ {results['compression_factor']:.1f}x spatial compression")
print(f"✓ {results['effective_speed_c']:.1f}c effective speed")

# Generate comprehensive plots
plot_v10_1_comprehensive(results)